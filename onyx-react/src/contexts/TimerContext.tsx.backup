import React, { createContext, useContext, useState, useCallback, ReactNode, useEffect, useRef } from 'react';
import { ActiveTimer } from '@/types/ActiveTimer';
import { TimerState } from '@/types/Timer';
import { useTimerExecution } from '@/hooks/useTimerExecution';
import { subjectService } from '@/services/subjectService';
import { SimpleActiveTimerWidget } from '@/components/SimpleActiveTimerWidget';
import { TopTimerIndicator } from '@/components/TopTimerIndicator';
import { useReactiveTimers } from '@/hooks/useReactiveTimers';
import { requestNotificationPermission } from '@/utils/audioNotifications';

interface TimerExecutionState {
  state: TimerState;
  timeRemaining: number;
  progress: number;
  sessionCount: number;
  currentCycle: number;
}

interface SyncOperation {
  id: string;
  operation: () => Promise<void>;
  timestamp: number;
  retryCount: number;
  maxRetries: number;
}

interface TimerVersion {
  id: string;
  version: number;
  lastModified: number;
  hash: string;
}

interface TimerContextType {
  timers: ActiveTimer[];
  startTimer: (timerId: string, timer: ActiveTimer) => void;
  pauseTimer: (timerId: string) => void;
  resetTimer: (timerId: string) => void;
  getTimerState: (timerId: string) => TimerExecutionState | null;
  cleanupTimer: (timerId: string) => void;
  setTimers: (timers: ActiveTimer[]) => void;
  // Fonctions de gestion des timers
  addTimer: (timer: Omit<ActiveTimer, 'id' | 'createdAt' | 'lastUsed'>) => Promise<ActiveTimer>;
  updateTimer: (id: string, updates: Partial<Omit<ActiveTimer, 'id' | 'createdAt'>>) => Promise<void>;
  removeTimer: (id: string) => Promise<void>;
  timerCounter: number;
  setTimerCounter: (counter: number | ((prev: number) => number)) => void;
  updateRunningTimer: (timerId: string, timer: ActiveTimer) => void;
}

const TimerContext = createContext<TimerContextType | undefined>(undefined);

export const useTimerContext = () => {
  const context = useContext(TimerContext);
  if (context === undefined) {
    throw new Error('useTimerContext must be used within a TimerProvider');
  }
  return context;
};

interface TimerProviderProps {
  children: ReactNode;
}

export const TimerProvider: React.FC<TimerProviderProps> = ({ children }) => {
  // Utiliser useReactiveTimers pour charger automatiquement les timers sauvegard√©s
  const { 
    timers: persistedTimers, 
    addTimer, 
    updateTimer, 
    removeTimer, 
    timerCounter, 
    setTimerCounter 
  } = useReactiveTimers();
  const [timers, setTimers] = useState<ActiveTimer[]>([]);
  const [isComponentMounted, setIsComponentMounted] = useState(true);
  
  // Syst√®me de synchronisation robuste
  const syncOperationQueue = useRef<SyncOperation[]>([]);
  const timerVersions = useRef<Map<string, TimerVersion>>(new Map());
  const consistencyCheckInterval = useRef<NodeJS.Timeout | null>(null);
  const syncLock = useRef<boolean>(false);
  const ephemeralTimerTimeouts = useRef<Map<string, NodeJS.Timeout>>(new Map());

  // Fonction pour normaliser un timer et s'assurer que les dates sont des objets Date
  const normalizeTimer = useCallback((timer: any): ActiveTimer => {
    return {
      ...timer,
      createdAt: timer.createdAt instanceof Date ? timer.createdAt : new Date(timer.createdAt),
      lastUsed: timer.lastUsed instanceof Date ? timer.lastUsed : new Date(timer.lastUsed),
      linkedSubject: timer.linkedSubject ? {
        ...timer.linkedSubject,
        createdAt: timer.linkedSubject.createdAt instanceof Date ? timer.linkedSubject.createdAt : new Date(timer.linkedSubject.createdAt),
        updatedAt: timer.linkedSubject.updatedAt instanceof Date ? timer.linkedSubject.updatedAt : new Date(timer.linkedSubject.updatedAt),
        lastStudyDate: timer.linkedSubject.lastStudyDate ? 
          (timer.linkedSubject.lastStudyDate instanceof Date ? timer.linkedSubject.lastStudyDate : new Date(timer.linkedSubject.lastStudyDate)) 
          : undefined
      } : undefined
    };
  }, []);

  // Fonctions utilitaires pour le syst√®me de synchronisation
  const generateTimerHash = useCallback((timer: ActiveTimer): string => {
    // G√©n√©rer un hash bas√© sur les propri√©t√©s importantes du timer
    const hashData = {
      title: timer.title,
      config: timer.config,
      isPomodoroMode: timer.isPomodoroMode,
      maxCycles: timer.maxCycles,
      linkedSubject: timer.linkedSubject?.id || null,
      lastUsed: timer.lastUsed instanceof Date ? timer.lastUsed.getTime() : new Date(timer.lastUsed).getTime()
    };
    return btoa(JSON.stringify(hashData));
  }, []);

  const updateTimerVersion = useCallback((timer: ActiveTimer) => {
    const hash = generateTimerHash(timer);
    const currentVersion = timerVersions.current.get(timer.id);
    const newVersion = {
      id: timer.id,
      version: (currentVersion?.version || 0) + 1,
      lastModified: Date.now(),
      hash
    };
    timerVersions.current.set(timer.id, newVersion);
    return newVersion;
  }, [generateTimerHash]);

  const detectConflict = useCallback((timerId: string, expectedHash: string): boolean => {
    const currentVersion = timerVersions.current.get(timerId);
    if (!currentVersion) return false;
    return currentVersion.hash !== expectedHash;
  }, []);

  // Queue des op√©rations de synchronisation avec retry
  const executeSyncOperation = useCallback(async (operation: SyncOperation): Promise<boolean> => {
    if (syncLock.current) {
      console.log('üîí Synchronisation d√©j√† en cours, ajout √† la queue');
      return false;
    }

    try {
      syncLock.current = true;
      console.log(`üîÑ Ex√©cution op√©ration de sync: ${operation.id}`);
      await operation.operation();
      console.log(`‚úÖ Op√©ration de sync r√©ussie: ${operation.id}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Erreur op√©ration de sync ${operation.id}:`, error);
      
      if (operation.retryCount < operation.maxRetries) {
        operation.retryCount++;
        operation.timestamp = Date.now() + (operation.retryCount * 1000); // D√©lai exponentiel
        syncOperationQueue.current.push(operation);
        console.log(`üîÑ Programmation retry ${operation.retryCount}/${operation.maxRetries} pour ${operation.id}`);
      } else {
        console.error(`‚ùå √âchec d√©finitif de l'op√©ration ${operation.id} apr√®s ${operation.maxRetries} tentatives`);
      }
      return false;
    } finally {
      syncLock.current = false;
    }
  }, []);

  const processSyncQueue = useCallback(async () => {
    if (syncOperationQueue.current.length === 0) return;
    
    const now = Date.now();
    const readyOperations = syncOperationQueue.current.filter(op => op.timestamp <= now);
    syncOperationQueue.current = syncOperationQueue.current.filter(op => op.timestamp > now);

    for (const operation of readyOperations) {
      await executeSyncOperation(operation);
    }
  }, [executeSyncOperation]);

  // Synchroniser avec les timers persist√©s au chargement - √©viter les re-rendus inutiles
  useEffect(() => {
    console.log('üîÑ TimerProvider - Synchronisation avec timers persist√©s:', persistedTimers.length);
    
    // V√©rifier si les timers ont vraiment chang√© avant de mettre √† jour
    setTimers(prevTimers => {
      if (JSON.stringify(prevTimers) === JSON.stringify(persistedTimers)) {
        console.log('üîÑ TimerProvider - Pas de changement, pas de mise √† jour');
        return prevTimers;
      }
      console.log('üîÑ TimerProvider - Mise √† jour des timers');
      
      // Normaliser et mettre √† jour les versions des timers
      const normalizedTimers = persistedTimers.map(timer => normalizeTimer(timer));
      normalizedTimers.forEach(timer => {
        updateTimerVersion(timer);
      });
      
      return normalizedTimers;
    });
  }, [persistedTimers, updateTimerVersion, normalizeTimer]);

  // Demander la permission pour les notifications au chargement
  useEffect(() => {
    requestNotificationPermission().then(granted => {
      if (granted) {
        console.log('‚úÖ Permission de notification accord√©e');
      } else {
        console.log('‚ùå Permission de notification refus√©e');
      }
    });
  }, []);

  // V√©rification p√©riodique de coh√©rence
  const performConsistencyCheck = useCallback(async () => {
    if (!isComponentMounted) return;
    
    try {
      console.log('üîç V√©rification de coh√©rence des timers');
      
      // V√©rifier la coh√©rence entre l'√©tat local et persist√©
      const currentTimers = timers;
      const storedTimers = persistedTimers;
      
      const inconsistencies: string[] = [];
      
      // V√©rifier les timers manquants ou d√©synchronis√©s
      for (const storedTimer of storedTimers) {
        const localTimer = currentTimers.find(t => t.id === storedTimer.id);
        if (!localTimer) {
          inconsistencies.push(`Timer ${storedTimer.id} manquant dans l'√©tat local`);
          continue;
        }
        
        const storedHash = generateTimerHash(storedTimer);
        const localHash = generateTimerHash(localTimer);
        if (storedHash !== localHash) {
          inconsistencies.push(`Timer ${storedTimer.id} d√©synchronis√©`);
        }
      }
      
      if (inconsistencies.length > 0) {
        console.warn('‚ö†Ô∏è Incoh√©rences d√©tect√©es:', inconsistencies);
        
        // Forcer une resynchronisation
        const syncOperation: SyncOperation = {
          id: `consistency-fix-${Date.now()}`,
          operation: async () => {
            console.log('üîß Correction des incoh√©rences d√©tect√©es');
            setTimers(persistedTimers);
            persistedTimers.forEach(timer => {
              updateTimerVersion(timer);
            });
          },
          timestamp: Date.now(),
          retryCount: 0,
          maxRetries: 2
        };
        
        syncOperationQueue.current.push(syncOperation);
        processSyncQueue();
      } else {
        console.log('‚úÖ Coh√©rence v√©rifi√©e - Aucune incoh√©rence d√©tect√©e');
      }
    } catch (error) {
      console.error('Erreur lors de la v√©rification de coh√©rence:', error);
    }
  }, [isComponentMounted, timers, persistedTimers, generateTimerHash, updateTimerVersion, processSyncQueue]);

  // Nettoyage lors du d√©montage du TimerProvider
  useEffect(() => {
    // D√©marrer la v√©rification p√©riodique de coh√©rence
    consistencyCheckInterval.current = setInterval(() => {
      performConsistencyCheck();
      processSyncQueue();
    }, 10000); // Toutes les 10 secondes
    
    return () => {
      console.log('üßπ TimerProvider - Nettoyage lors du d√©montage');
      setIsComponentMounted(false);
      
      // Nettoyer l'intervalle de v√©rification
      if (consistencyCheckInterval.current) {
        clearInterval(consistencyCheckInterval.current);
        consistencyCheckInterval.current = null;
      }
      
      // Nettoyer tous les timeouts des timers √©ph√©m√®res
      ephemeralTimerTimeouts.current.forEach((timeoutId) => {
        clearTimeout(timeoutId);
      });
      ephemeralTimerTimeouts.current.clear();
      
      // Vider la queue de synchronisation
      syncOperationQueue.current = [];
      timerVersions.current.clear();
      
      console.log('‚úÖ TimerProvider - Nettoyage termin√©');
    };
  }, [performConsistencyCheck, processSyncQueue]);

  const {
    startTimer,
    pauseTimer,
    resetTimer,
    getTimerState,
    cleanupTimer,
    updateRunningTimer
  } = useTimerExecution(
    // onTimerFinish callback
    useCallback(async (_timerId: string, timer: ActiveTimer, totalTime: number) => {
      console.log(`üéØ [DEBUG] onTimerFinish appel√© ! Timer: ${timer.title}, totalTime: ${totalTime}s, linkedSubject: ${timer.linkedSubject ? timer.linkedSubject.name : 'AUCUN'}`);
      
      // V√©rifier que le composant est encore mont√©
      if (!isComponentMounted) {
        console.log('‚ö†Ô∏è onTimerFinish ignor√© - composant d√©mont√©');
        return;
      }
      
      // Si c'est un timer √©ph√©m√®re, le supprimer automatiquement √† la fin
      if (timer.isEphemeral) {
        console.log('‚è±Ô∏è Suppression automatique du timer √©ph√©m√®re termin√©:', timer.title);
        try {
          // Nettoyer tout timeout existant pour ce timer
          const existingTimeout = ephemeralTimerTimeouts.current.get(timer.id);
          if (existingTimeout) {
            clearTimeout(existingTimeout);
          }
          
          // D√©lai de 2 secondes pour laisser les notifications/sons se terminer
          const timeoutId = setTimeout(async () => {
            if (isComponentMounted) {
              await removeTimer(timer.id);
              console.log('‚úÖ Timer √©ph√©m√®re termin√© et supprim√© avec succ√®s');
              // Nettoyer la r√©f√©rence du timeout
              ephemeralTimerTimeouts.current.delete(timer.id);
            }
          }, 2000);
          
          // Stocker la r√©f√©rence du timeout
          ephemeralTimerTimeouts.current.set(timer.id, timeoutId);
        } catch (error) {
          console.error('Erreur suppression timer √©ph√©m√®re:', error);
        }
      }
      
      if (timer.linkedSubject) {
        try {
          console.log(`üéØ [DEBUG] Ajout temps d'√©tude via onTimerFinish - Subject: ${timer.linkedSubject.name}, Temps: ${totalTime}s (${Math.round(totalTime/60)}min)`);
          await subjectService.addStudyTime(timer.linkedSubject.id, totalTime);
          console.log(`‚úÖ [DEBUG] Temps d'√©tude ajout√© avec succ√®s via onTimerFinish !`);
        } catch (error) {
          console.error('‚ùå [DEBUG] Erreur lors de l\'ajout du temps d\'√©tude via onTimerFinish:', error);
        }
      } else {
        console.warn(`‚ö†Ô∏è [DEBUG] onTimerFinish: Timer "${timer.title}" n'a pas de linkedSubject !`);
      }
    }, [removeTimer, isComponentMounted]),
    // onSessionComplete callback
    useCallback(async (timerId: string, timer: ActiveTimer) => {
      console.log(`üîî [DEBUG] onSessionComplete d√©clench√© pour timer ${timerId}: ${timer.title}, linkedSubject: ${timer.linkedSubject ? timer.linkedSubject.name : 'AUCUN'}`);
      
      // V√©rifier que le composant est encore mont√©
      if (!isComponentMounted) {
        console.log('‚ö†Ô∏è onSessionComplete ignor√© - composant d√©mont√©');
        return;
      }
      
      if (timer.linkedSubject) {
        try {
          const studyTimeInSeconds = timer.config.workDuration; // d√©j√† en secondes
          console.log(`üìä Enregistrement temps d'√©tude: ${timer.linkedSubject.name} - ${Math.round(studyTimeInSeconds / 60)}min`);
          
          await subjectService.addStudyTime(
            timer.linkedSubject.id, 
            studyTimeInSeconds
          );
          
          console.log(`‚úÖ Temps d'√©tude ajout√© avec succ√®s pour ${timer.linkedSubject.name}`);
          
          // üîÑ D√©clencher une actualisation des donn√©es
          // Notifier les composants que les donn√©es du sujet ont chang√©
          window.dispatchEvent(new CustomEvent('subjectDataChanged', {
            detail: { subjectId: timer.linkedSubject.id, subjectName: timer.linkedSubject.name }
          }));
        } catch (error) {
          console.error(`‚ùå Erreur lors de l'ajout du temps d'√©tude pour ${timer.linkedSubject?.name}:`, error);
        }
      } else {
        console.warn(`‚ö†Ô∏è onSessionComplete appel√© mais aucun linkedSubject pour timer: ${timer.title}`);
      }
    }, [isComponentMounted])
  );

  const handleTimerAction = useCallback((action: 'start' | 'pause' | 'reset', timer: ActiveTimer) => {
    switch (action) {
      case 'start':
        startTimer(timer.id, timer);
        break;
      case 'pause':
        pauseTimer(timer.id);
        break;
      case 'reset':
        resetTimer(timer.id);
        break;
    }
  }, [startTimer, pauseTimer, resetTimer]);

  // Wrapper pour setTimers qui met √† jour √† la fois l'√©tat local et persist√©
  const updateTimers = useCallback((newTimers: ActiveTimer[]) => {
    console.log('üîÑ TimerProvider - Mise √† jour des timers:', newTimers.length);
    setTimers(newTimers);
  }, []);

  // Wrapper pour updateTimer qui met √† jour aussi les timers en cours avec gestion robuste des conflits
  const updateTimerWithSync = useCallback(async (id: string, updates: Partial<Omit<ActiveTimer, 'id' | 'createdAt'>>) => {
    const currentTimer = timers.find(t => t.id === id);
    if (!currentTimer) {
      throw new Error(`Timer ${id} introuvable`);
    }

    const currentVersion = timerVersions.current.get(id);
    const expectedHash = currentVersion?.hash || generateTimerHash(currentTimer);
    
    // Cr√©er une op√©ration de synchronisation atomique
    const syncOperation: SyncOperation = {
      id: `update-timer-${id}-${Date.now()}`,
      operation: async () => {
        // V√©rifier les conflits avant la mise √† jour
        if (detectConflict(id, expectedHash)) {
          console.warn(`‚ö†Ô∏è Conflit d√©tect√© pour timer ${id}, r√©solution automatique`);
          
          // Recharger le timer depuis le stockage pour r√©soudre le conflit
          const latestTimer = persistedTimers.find(t => t.id === id);
          if (latestTimer) {
            // Fusionner les mises √† jour avec la derni√®re version
            const resolvedUpdates = {
              ...updates,
              lastUsed: new Date(Math.max(
                latestTimer.lastUsed.getTime(),
                updates.lastUsed?.getTime() || Date.now()
              ))
            };
            
            await updateTimer(id, resolvedUpdates);
            const resolvedTimer = { ...latestTimer, ...resolvedUpdates };
            updateTimerVersion(resolvedTimer);
            
            console.log(`‚úÖ Conflit r√©solu pour timer ${id}`);
          } else {
            throw new Error(`Timer ${id} introuvable lors de la r√©solution de conflit`);
          }
        } else {
          // Pas de conflit, mise √† jour normale
          await updateTimer(id, updates);
          const updatedTimer = { ...currentTimer, ...updates, lastUsed: new Date() };
          updateTimerVersion(updatedTimer);
        }
        
        // Si le timer est en cours d'ex√©cution, le mettre √† jour aussi
        const timerState = getTimerState(id);
        if (timerState && (timerState.state === 'running' || timerState.state === 'paused')) {
          const updatedTimer = timers.find(t => t.id === id);
          if (updatedTimer) {
            // Cr√©er le timer avec les mises √† jour appliqu√©es
            const mergedTimer = { ...updatedTimer, ...updates, lastUsed: new Date() };
            updateRunningTimer(id, mergedTimer);
            console.log(`üîÑ Timer en cours ${id} synchronis√© avec nouvelles modifications`);
          }
        }
      },
      timestamp: Date.now(),
      retryCount: 0,
      maxRetries: 3
    };

    // Ajouter √† la queue et traiter imm√©diatement
    syncOperationQueue.current.push(syncOperation);
    await processSyncQueue();
  }, [timers, timerVersions, generateTimerHash, detectConflict, persistedTimers, updateTimer, updateTimerVersion, getTimerState, updateRunningTimer, processSyncQueue]);

  const value: TimerContextType = {
    timers,
    startTimer,
    pauseTimer,
    resetTimer,
    getTimerState,
    cleanupTimer,
    setTimers: updateTimers,
    // Exposer les fonctions de gestion des timers
    addTimer,
    updateTimer: updateTimerWithSync,
    removeTimer,
    timerCounter,
    setTimerCounter,
    updateRunningTimer
  };

  return (
    <TimerContext.Provider value={value}>
      {children}
      {/* Indicateur discret en haut de page */}
      <TopTimerIndicator
        timers={timers}
        getTimerState={getTimerState}
      />
      {/* Widget global - s'affiche sur toutes les pages */}
      <SimpleActiveTimerWidget
        timers={timers}
        getTimerState={getTimerState}
        onTimerAction={handleTimerAction}
      />
    </TimerContext.Provider>
  );
};